<<<<<<< HEAD
=======
import type { Buffer } from 'buffer';
>>>>>>> main
import { Binary } from '../binary';
import type { BSONSymbol, DBRef, Document, MaxKey } from '../bson';
import type { Code } from '../code';
import * as constants from '../constants';
import type { DBRefLike } from '../db_ref';
import type { Decimal128 } from '../decimal128';
import type { Double } from '../double';
<<<<<<< HEAD
import { BSONError, BSONVersionError } from '../error';
import type { Int32 } from '../int_32';
import { Long } from '../long';
import type { MinKey } from '../min_key';
import type { ObjectId } from '../objectid';
import type { BSONRegExp } from '../regexp';
import { ByteUtils } from '../utils/byte_utils';
import { isAnyArrayBuffer, isDate, isMap, isRegExp, isUint8Array } from './utils';
=======
import { ensureBuffer } from '../ensure_buffer';
import { BSONError, BSONTypeError } from '../error';
import { isBSONType } from '../extended_json';
import type { Int32 } from '../int_32';
import { Long } from '../long';
import { Map } from '../map';
import type { MinKey } from '../min_key';
import type { ObjectId } from '../objectid';
import type { BSONRegExp } from '../regexp';
import {
  isBigInt64Array,
  isBigUInt64Array,
  isDate,
  isMap,
  isRegExp,
  isUint8Array,
  normalizedFunctionString
} from './utils';
>>>>>>> main

/** @public */
export interface SerializeOptions {
  /** the serializer will check if keys are valid. */
  checkKeys?: boolean;
  /** serialize the javascript functions **(default:false)**. */
  serializeFunctions?: boolean;
  /** serialize will not emit undefined fields **(default:true)** */
  ignoreUndefined?: boolean;
  /** @internal Resize internal buffer */
  minInternalBufferSize?: number;
  /** the index in the buffer where we wish to start serializing into */
  index?: number;
}

const regexp = /\x00/; // eslint-disable-line no-control-regex
const ignoreKeys = new Set(['$db', '$ref', '$id', '$clusterTime']);

/*
 * isArray indicates if we are writing to a BSON array (type 0x04)
 * which forces the "key" which really an array index as a string to be written as ascii
 * This will catch any errors in index as a string generation
 */

<<<<<<< HEAD
function serializeString(buffer: Uint8Array, key: string, value: string, index: number) {
  // Encode String type
  buffer[index++] = constants.BSON_DATA_STRING;
  // Number of written bytes
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
=======
function serializeString(
  buffer: Buffer,
  key: string,
  value: string,
  index: number,
  isArray?: boolean
) {
  // Encode String type
  buffer[index++] = constants.BSON_DATA_STRING;
  // Number of written bytes
  const numberOfWrittenBytes = !isArray
    ? buffer.write(key, index, undefined, 'utf8')
    : buffer.write(key, index, undefined, 'ascii');
>>>>>>> main
  // Encode the name
  index = index + numberOfWrittenBytes + 1;
  buffer[index - 1] = 0;
  // Write the string
<<<<<<< HEAD
  const size = ByteUtils.encodeUTF8Into(buffer, value, index + 4);
=======
  const size = buffer.write(value, index + 4, undefined, 'utf8');
>>>>>>> main
  // Write the size of the string to buffer
  buffer[index + 3] = ((size + 1) >> 24) & 0xff;
  buffer[index + 2] = ((size + 1) >> 16) & 0xff;
  buffer[index + 1] = ((size + 1) >> 8) & 0xff;
  buffer[index] = (size + 1) & 0xff;
  // Update index
  index = index + 4 + size;
  // Write zero
  buffer[index++] = 0;
  return index;
}

<<<<<<< HEAD
const NUMBER_SPACE = new DataView(new ArrayBuffer(8), 0, 8);
const FOUR_BYTE_VIEW_ON_NUMBER = new Uint8Array(NUMBER_SPACE.buffer, 0, 4);
const EIGHT_BYTE_VIEW_ON_NUMBER = new Uint8Array(NUMBER_SPACE.buffer, 0, 8);

function serializeNumber(buffer: Uint8Array, key: string, value: number, index: number) {
  const isNegativeZero = Object.is(value, -0);

  const type =
    !isNegativeZero &&
    Number.isSafeInteger(value) &&
    value <= constants.BSON_INT32_MAX &&
    value >= constants.BSON_INT32_MIN
      ? constants.BSON_DATA_INT
      : constants.BSON_DATA_NUMBER;

  if (type === constants.BSON_DATA_INT) {
    NUMBER_SPACE.setInt32(0, value, true);
  } else {
    NUMBER_SPACE.setFloat64(0, value, true);
  }

  const bytes =
    type === constants.BSON_DATA_INT ? FOUR_BYTE_VIEW_ON_NUMBER : EIGHT_BYTE_VIEW_ON_NUMBER;

  buffer[index++] = type;

  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0x00;

  buffer.set(bytes, index);
  index += bytes.byteLength;

  return index;
}

function serializeBigInt(buffer: Uint8Array, key: string, value: bigint, index: number) {
  buffer[index++] = constants.BSON_DATA_LONG;
  // Number of written bytes
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
  // Encode the name
  index += numberOfWrittenBytes;
  buffer[index++] = 0;
  NUMBER_SPACE.setBigInt64(0, value, true);
  // Write BigInt value
  buffer.set(EIGHT_BYTE_VIEW_ON_NUMBER, index);
  index += EIGHT_BYTE_VIEW_ON_NUMBER.byteLength;
  return index;
}

function serializeNull(buffer: Uint8Array, key: string, _: unknown, index: number) {
=======
const SPACE_FOR_FLOAT64 = new Uint8Array(8);
const DV_FOR_FLOAT64 = new DataView(
  SPACE_FOR_FLOAT64.buffer,
  SPACE_FOR_FLOAT64.byteOffset,
  SPACE_FOR_FLOAT64.byteLength
);
function serializeNumber(
  buffer: Buffer,
  key: string,
  value: number,
  index: number,
  isArray?: boolean
) {
  // We have an integer value
  // TODO(NODE-2529): Add support for big int
  if (
    Number.isInteger(value) &&
    value >= constants.BSON_INT32_MIN &&
    value <= constants.BSON_INT32_MAX
  ) {
    // If the value fits in 32 bits encode as int32
    // Set int type 32 bits or less
    buffer[index++] = constants.BSON_DATA_INT;
    // Number of written bytes
    const numberOfWrittenBytes = !isArray
      ? buffer.write(key, index, undefined, 'utf8')
      : buffer.write(key, index, undefined, 'ascii');
    // Encode the name
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    // Write the int value
    buffer[index++] = value & 0xff;
    buffer[index++] = (value >> 8) & 0xff;
    buffer[index++] = (value >> 16) & 0xff;
    buffer[index++] = (value >> 24) & 0xff;
  } else {
    // Encode as double
    buffer[index++] = constants.BSON_DATA_NUMBER;
    // Number of written bytes
    const numberOfWrittenBytes = !isArray
      ? buffer.write(key, index, undefined, 'utf8')
      : buffer.write(key, index, undefined, 'ascii');
    // Encode the name
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    // Write float
    DV_FOR_FLOAT64.setFloat64(0, value, true);
    buffer.set(SPACE_FOR_FLOAT64, index);
    // Adjust index
    index = index + 8;
  }

  return index;
}

function serializeNull(buffer: Buffer, key: string, _: unknown, index: number, isArray?: boolean) {
>>>>>>> main
  // Set long type
  buffer[index++] = constants.BSON_DATA_NULL;

  // Number of written bytes
<<<<<<< HEAD
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
=======
  const numberOfWrittenBytes = !isArray
    ? buffer.write(key, index, undefined, 'utf8')
    : buffer.write(key, index, undefined, 'ascii');
>>>>>>> main

  // Encode the name
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  return index;
}

<<<<<<< HEAD
function serializeBoolean(buffer: Uint8Array, key: string, value: boolean, index: number) {
  // Write the type
  buffer[index++] = constants.BSON_DATA_BOOLEAN;
  // Number of written bytes
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
=======
function serializeBoolean(
  buffer: Buffer,
  key: string,
  value: boolean,
  index: number,
  isArray?: boolean
) {
  // Write the type
  buffer[index++] = constants.BSON_DATA_BOOLEAN;
  // Number of written bytes
  const numberOfWrittenBytes = !isArray
    ? buffer.write(key, index, undefined, 'utf8')
    : buffer.write(key, index, undefined, 'ascii');
>>>>>>> main
  // Encode the name
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  // Encode the boolean value
  buffer[index++] = value ? 1 : 0;
  return index;
}

<<<<<<< HEAD
function serializeDate(buffer: Uint8Array, key: string, value: Date, index: number) {
  // Write the type
  buffer[index++] = constants.BSON_DATA_DATE;
  // Number of written bytes
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
=======
function serializeDate(buffer: Buffer, key: string, value: Date, index: number, isArray?: boolean) {
  // Write the type
  buffer[index++] = constants.BSON_DATA_DATE;
  // Number of written bytes
  const numberOfWrittenBytes = !isArray
    ? buffer.write(key, index, undefined, 'utf8')
    : buffer.write(key, index, undefined, 'ascii');
>>>>>>> main
  // Encode the name
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;

  // Write the date
  const dateInMilis = Long.fromNumber(value.getTime());
  const lowBits = dateInMilis.getLowBits();
  const highBits = dateInMilis.getHighBits();
  // Encode low bits
  buffer[index++] = lowBits & 0xff;
  buffer[index++] = (lowBits >> 8) & 0xff;
  buffer[index++] = (lowBits >> 16) & 0xff;
  buffer[index++] = (lowBits >> 24) & 0xff;
  // Encode high bits
  buffer[index++] = highBits & 0xff;
  buffer[index++] = (highBits >> 8) & 0xff;
  buffer[index++] = (highBits >> 16) & 0xff;
  buffer[index++] = (highBits >> 24) & 0xff;
  return index;
}

<<<<<<< HEAD
function serializeRegExp(buffer: Uint8Array, key: string, value: RegExp, index: number) {
  // Write the type
  buffer[index++] = constants.BSON_DATA_REGEXP;
  // Number of written bytes
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
=======
function serializeRegExp(
  buffer: Buffer,
  key: string,
  value: RegExp,
  index: number,
  isArray?: boolean
) {
  // Write the type
  buffer[index++] = constants.BSON_DATA_REGEXP;
  // Number of written bytes
  const numberOfWrittenBytes = !isArray
    ? buffer.write(key, index, undefined, 'utf8')
    : buffer.write(key, index, undefined, 'ascii');
>>>>>>> main

  // Encode the name
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  if (value.source && value.source.match(regexp) != null) {
<<<<<<< HEAD
    throw new BSONError('value ' + value.source + ' must not contain null bytes');
  }
  // Adjust the index
  index = index + ByteUtils.encodeUTF8Into(buffer, value.source, index);
=======
    throw Error('value ' + value.source + ' must not contain null bytes');
  }
  // Adjust the index
  index = index + buffer.write(value.source, index, undefined, 'utf8');
>>>>>>> main
  // Write zero
  buffer[index++] = 0x00;
  // Write the parameters
  if (value.ignoreCase) buffer[index++] = 0x69; // i
  if (value.global) buffer[index++] = 0x73; // s
  if (value.multiline) buffer[index++] = 0x6d; // m

  // Add ending zero
  buffer[index++] = 0x00;
  return index;
}

<<<<<<< HEAD
function serializeBSONRegExp(buffer: Uint8Array, key: string, value: BSONRegExp, index: number) {
  // Write the type
  buffer[index++] = constants.BSON_DATA_REGEXP;
  // Number of written bytes
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
=======
function serializeBSONRegExp(
  buffer: Buffer,
  key: string,
  value: BSONRegExp,
  index: number,
  isArray?: boolean
) {
  // Write the type
  buffer[index++] = constants.BSON_DATA_REGEXP;
  // Number of written bytes
  const numberOfWrittenBytes = !isArray
    ? buffer.write(key, index, undefined, 'utf8')
    : buffer.write(key, index, undefined, 'ascii');
>>>>>>> main
  // Encode the name
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;

  // Check the pattern for 0 bytes
  if (value.pattern.match(regexp) != null) {
    // The BSON spec doesn't allow keys with null bytes because keys are
    // null-terminated.
<<<<<<< HEAD
    throw new BSONError('pattern ' + value.pattern + ' must not contain null bytes');
  }

  // Adjust the index
  index = index + ByteUtils.encodeUTF8Into(buffer, value.pattern, index);
  // Write zero
  buffer[index++] = 0x00;
  // Write the options
  const sortedOptions = value.options.split('').sort().join('');
  index = index + ByteUtils.encodeUTF8Into(buffer, sortedOptions, index);
=======
    throw Error('pattern ' + value.pattern + ' must not contain null bytes');
  }

  // Adjust the index
  index = index + buffer.write(value.pattern, index, undefined, 'utf8');
  // Write zero
  buffer[index++] = 0x00;
  // Write the options
  index = index + buffer.write(value.options.split('').sort().join(''), index, undefined, 'utf8');
>>>>>>> main
  // Add ending zero
  buffer[index++] = 0x00;
  return index;
}

<<<<<<< HEAD
function serializeMinMax(buffer: Uint8Array, key: string, value: MinKey | MaxKey, index: number) {
=======
function serializeMinMax(
  buffer: Buffer,
  key: string,
  value: MinKey | MaxKey,
  index: number,
  isArray?: boolean
) {
>>>>>>> main
  // Write the type of either min or max key
  if (value === null) {
    buffer[index++] = constants.BSON_DATA_NULL;
  } else if (value._bsontype === 'MinKey') {
    buffer[index++] = constants.BSON_DATA_MIN_KEY;
  } else {
    buffer[index++] = constants.BSON_DATA_MAX_KEY;
  }

  // Number of written bytes
<<<<<<< HEAD
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
=======
  const numberOfWrittenBytes = !isArray
    ? buffer.write(key, index, undefined, 'utf8')
    : buffer.write(key, index, undefined, 'ascii');
>>>>>>> main
  // Encode the name
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  return index;
}

<<<<<<< HEAD
function serializeObjectId(buffer: Uint8Array, key: string, value: ObjectId, index: number) {
  // Write the type
  buffer[index++] = constants.BSON_DATA_OID;
  // Number of written bytes
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
=======
function serializeObjectId(
  buffer: Buffer,
  key: string,
  value: ObjectId,
  index: number,
  isArray?: boolean
) {
  // Write the type
  buffer[index++] = constants.BSON_DATA_OID;
  // Number of written bytes
  const numberOfWrittenBytes = !isArray
    ? buffer.write(key, index, undefined, 'utf8')
    : buffer.write(key, index, undefined, 'ascii');
>>>>>>> main

  // Encode the name
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;

  // Write the objectId into the shared buffer
<<<<<<< HEAD
  if (isUint8Array(value.id)) {
    buffer.set(value.id.subarray(0, 12), index);
  } else {
    throw new BSONError('object [' + JSON.stringify(value) + '] is not a valid ObjectId');
=======
  if (typeof value.id === 'string') {
    buffer.write(value.id, index, undefined, 'binary');
  } else if (isUint8Array(value.id)) {
    // Use the standard JS methods here because buffer.copy() is buggy with the
    // browser polyfill
    buffer.set(value.id.subarray(0, 12), index);
  } else {
    throw new BSONTypeError('object [' + JSON.stringify(value) + '] is not a valid ObjectId');
>>>>>>> main
  }

  // Adjust index
  return index + 12;
}

<<<<<<< HEAD
function serializeBuffer(buffer: Uint8Array, key: string, value: Uint8Array, index: number) {
  // Write the type
  buffer[index++] = constants.BSON_DATA_BINARY;
  // Number of written bytes
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
=======
function serializeBuffer(
  buffer: Buffer,
  key: string,
  value: Buffer | Uint8Array,
  index: number,
  isArray?: boolean
) {
  // Write the type
  buffer[index++] = constants.BSON_DATA_BINARY;
  // Number of written bytes
  const numberOfWrittenBytes = !isArray
    ? buffer.write(key, index, undefined, 'utf8')
    : buffer.write(key, index, undefined, 'ascii');
>>>>>>> main
  // Encode the name
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  // Get size of the buffer (current write point)
  const size = value.length;
  // Write the size of the string to buffer
  buffer[index++] = size & 0xff;
  buffer[index++] = (size >> 8) & 0xff;
  buffer[index++] = (size >> 16) & 0xff;
  buffer[index++] = (size >> 24) & 0xff;
  // Write the default subtype
  buffer[index++] = constants.BSON_BINARY_SUBTYPE_DEFAULT;
  // Copy the content form the binary field to the buffer
<<<<<<< HEAD
  buffer.set(value, index);
=======
  buffer.set(ensureBuffer(value), index);
>>>>>>> main
  // Adjust the index
  index = index + size;
  return index;
}

function serializeObject(
<<<<<<< HEAD
  buffer: Uint8Array,
  key: string,
  value: Document,
  index: number,
  checkKeys: boolean,
  depth: number,
  serializeFunctions: boolean,
  ignoreUndefined: boolean,
  path: Set<Document>
) {
  if (path.has(value)) {
    throw new BSONError('Cannot convert circular structure to BSON');
  }

  path.add(value);

  // Write the type
  buffer[index++] = Array.isArray(value) ? constants.BSON_DATA_ARRAY : constants.BSON_DATA_OBJECT;
  // Number of written bytes
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
=======
  buffer: Buffer,
  key: string,
  value: Document,
  index: number,
  checkKeys = false,
  depth = 0,
  serializeFunctions = false,
  ignoreUndefined = true,
  isArray = false,
  path: Document[] = []
) {
  for (let i = 0; i < path.length; i++) {
    if (path[i] === value) throw new BSONError('cyclic dependency detected');
  }

  // Push value to stack
  path.push(value);
  // Write the type
  buffer[index++] = Array.isArray(value) ? constants.BSON_DATA_ARRAY : constants.BSON_DATA_OBJECT;
  // Number of written bytes
  const numberOfWrittenBytes = !isArray
    ? buffer.write(key, index, undefined, 'utf8')
    : buffer.write(key, index, undefined, 'ascii');
>>>>>>> main
  // Encode the name
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  const endIndex = serializeInto(
    buffer,
    value,
    checkKeys,
    index,
    depth + 1,
    serializeFunctions,
    ignoreUndefined,
    path
  );
<<<<<<< HEAD

  path.delete(value);

  return endIndex;
}

function serializeDecimal128(buffer: Uint8Array, key: string, value: Decimal128, index: number) {
  buffer[index++] = constants.BSON_DATA_DECIMAL128;
  // Number of written bytes
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
=======
  // Pop stack
  path.pop();
  return endIndex;
}

function serializeDecimal128(
  buffer: Buffer,
  key: string,
  value: Decimal128,
  index: number,
  isArray?: boolean
) {
  buffer[index++] = constants.BSON_DATA_DECIMAL128;
  // Number of written bytes
  const numberOfWrittenBytes = !isArray
    ? buffer.write(key, index, undefined, 'utf8')
    : buffer.write(key, index, undefined, 'ascii');
>>>>>>> main
  // Encode the name
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  // Write the data from the value
<<<<<<< HEAD
=======
  // Prefer the standard JS methods because their typechecking is not buggy,
  // unlike the `buffer` polyfill's.
>>>>>>> main
  buffer.set(value.bytes.subarray(0, 16), index);
  return index + 16;
}

<<<<<<< HEAD
function serializeLong(buffer: Uint8Array, key: string, value: Long, index: number) {
=======
function serializeLong(buffer: Buffer, key: string, value: Long, index: number, isArray?: boolean) {
>>>>>>> main
  // Write the type
  buffer[index++] =
    value._bsontype === 'Long' ? constants.BSON_DATA_LONG : constants.BSON_DATA_TIMESTAMP;
  // Number of written bytes
<<<<<<< HEAD
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
=======
  const numberOfWrittenBytes = !isArray
    ? buffer.write(key, index, undefined, 'utf8')
    : buffer.write(key, index, undefined, 'ascii');
>>>>>>> main
  // Encode the name
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  // Write the date
  const lowBits = value.getLowBits();
  const highBits = value.getHighBits();
  // Encode low bits
  buffer[index++] = lowBits & 0xff;
  buffer[index++] = (lowBits >> 8) & 0xff;
  buffer[index++] = (lowBits >> 16) & 0xff;
  buffer[index++] = (lowBits >> 24) & 0xff;
  // Encode high bits
  buffer[index++] = highBits & 0xff;
  buffer[index++] = (highBits >> 8) & 0xff;
  buffer[index++] = (highBits >> 16) & 0xff;
  buffer[index++] = (highBits >> 24) & 0xff;
  return index;
}

<<<<<<< HEAD
function serializeInt32(buffer: Uint8Array, key: string, value: Int32 | number, index: number) {
=======
function serializeInt32(
  buffer: Buffer,
  key: string,
  value: Int32 | number,
  index: number,
  isArray?: boolean
) {
>>>>>>> main
  value = value.valueOf();
  // Set int type 32 bits or less
  buffer[index++] = constants.BSON_DATA_INT;
  // Number of written bytes
<<<<<<< HEAD
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
=======
  const numberOfWrittenBytes = !isArray
    ? buffer.write(key, index, undefined, 'utf8')
    : buffer.write(key, index, undefined, 'ascii');
>>>>>>> main
  // Encode the name
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  // Write the int value
  buffer[index++] = value & 0xff;
  buffer[index++] = (value >> 8) & 0xff;
  buffer[index++] = (value >> 16) & 0xff;
  buffer[index++] = (value >> 24) & 0xff;
  return index;
}

<<<<<<< HEAD
function serializeDouble(buffer: Uint8Array, key: string, value: Double, index: number) {
=======
function serializeDouble(
  buffer: Buffer,
  key: string,
  value: Double,
  index: number,
  isArray?: boolean
) {
>>>>>>> main
  // Encode as double
  buffer[index++] = constants.BSON_DATA_NUMBER;

  // Number of written bytes
<<<<<<< HEAD
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
=======
  const numberOfWrittenBytes = !isArray
    ? buffer.write(key, index, undefined, 'utf8')
    : buffer.write(key, index, undefined, 'ascii');
>>>>>>> main

  // Encode the name
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;

  // Write float
<<<<<<< HEAD
  NUMBER_SPACE.setFloat64(0, value.value, true);
  buffer.set(EIGHT_BYTE_VIEW_ON_NUMBER, index);
=======
  DV_FOR_FLOAT64.setFloat64(0, value.value, true);
  buffer.set(SPACE_FOR_FLOAT64, index);
>>>>>>> main

  // Adjust index
  index = index + 8;
  return index;
}

<<<<<<< HEAD
function serializeFunction(buffer: Uint8Array, key: string, value: Function, index: number) {
  buffer[index++] = constants.BSON_DATA_CODE;
  // Number of written bytes
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
=======
function serializeFunction(
  buffer: Buffer,
  key: string,
  value: Function,
  index: number,
  _checkKeys = false,
  _depth = 0,
  isArray?: boolean
) {
  buffer[index++] = constants.BSON_DATA_CODE;
  // Number of written bytes
  const numberOfWrittenBytes = !isArray
    ? buffer.write(key, index, undefined, 'utf8')
    : buffer.write(key, index, undefined, 'ascii');
>>>>>>> main
  // Encode the name
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  // Function string
<<<<<<< HEAD
  const functionString = value.toString();

  // Write the string
  const size = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1;
=======
  const functionString = normalizedFunctionString(value);

  // Write the string
  const size = buffer.write(functionString, index + 4, undefined, 'utf8') + 1;
>>>>>>> main
  // Write the size of the string to buffer
  buffer[index] = size & 0xff;
  buffer[index + 1] = (size >> 8) & 0xff;
  buffer[index + 2] = (size >> 16) & 0xff;
  buffer[index + 3] = (size >> 24) & 0xff;
  // Update index
  index = index + 4 + size - 1;
  // Write zero
  buffer[index++] = 0;
  return index;
}

function serializeCode(
<<<<<<< HEAD
  buffer: Uint8Array,
=======
  buffer: Buffer,
>>>>>>> main
  key: string,
  value: Code,
  index: number,
  checkKeys = false,
  depth = 0,
  serializeFunctions = false,
  ignoreUndefined = true,
<<<<<<< HEAD
  path: Set<Document>
=======
  isArray = false
>>>>>>> main
) {
  if (value.scope && typeof value.scope === 'object') {
    // Write the type
    buffer[index++] = constants.BSON_DATA_CODE_W_SCOPE;
    // Number of written bytes
<<<<<<< HEAD
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
=======
    const numberOfWrittenBytes = !isArray
      ? buffer.write(key, index, undefined, 'utf8')
      : buffer.write(key, index, undefined, 'ascii');
>>>>>>> main
    // Encode the name
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;

    // Starting index
    let startIndex = index;

    // Serialize the function
    // Get the function string
<<<<<<< HEAD
    const functionString = value.code;
    // Index adjustment
    index = index + 4;
    // Write string into buffer
    const codeSize = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1;
=======
    const functionString = typeof value.code === 'string' ? value.code : value.code.toString();
    // Index adjustment
    index = index + 4;
    // Write string into buffer
    const codeSize = buffer.write(functionString, index + 4, undefined, 'utf8') + 1;
>>>>>>> main
    // Write the size of the string to buffer
    buffer[index] = codeSize & 0xff;
    buffer[index + 1] = (codeSize >> 8) & 0xff;
    buffer[index + 2] = (codeSize >> 16) & 0xff;
    buffer[index + 3] = (codeSize >> 24) & 0xff;
    // Write end 0
    buffer[index + 4 + codeSize - 1] = 0;
    // Write the
    index = index + codeSize + 4;

<<<<<<< HEAD
=======
    //
>>>>>>> main
    // Serialize the scope value
    const endIndex = serializeInto(
      buffer,
      value.scope,
      checkKeys,
      index,
      depth + 1,
      serializeFunctions,
<<<<<<< HEAD
      ignoreUndefined,
      path
=======
      ignoreUndefined
>>>>>>> main
    );
    index = endIndex - 1;

    // Writ the total
    const totalSize = endIndex - startIndex;

    // Write the total size of the object
    buffer[startIndex++] = totalSize & 0xff;
    buffer[startIndex++] = (totalSize >> 8) & 0xff;
    buffer[startIndex++] = (totalSize >> 16) & 0xff;
    buffer[startIndex++] = (totalSize >> 24) & 0xff;
    // Write trailing zero
    buffer[index++] = 0;
  } else {
    buffer[index++] = constants.BSON_DATA_CODE;
    // Number of written bytes
<<<<<<< HEAD
    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
=======
    const numberOfWrittenBytes = !isArray
      ? buffer.write(key, index, undefined, 'utf8')
      : buffer.write(key, index, undefined, 'ascii');
>>>>>>> main
    // Encode the name
    index = index + numberOfWrittenBytes;
    buffer[index++] = 0;
    // Function string
    const functionString = value.code.toString();
    // Write the string
<<<<<<< HEAD
    const size = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1;
=======
    const size = buffer.write(functionString, index + 4, undefined, 'utf8') + 1;
>>>>>>> main
    // Write the size of the string to buffer
    buffer[index] = size & 0xff;
    buffer[index + 1] = (size >> 8) & 0xff;
    buffer[index + 2] = (size >> 16) & 0xff;
    buffer[index + 3] = (size >> 24) & 0xff;
    // Update index
    index = index + 4 + size - 1;
    // Write zero
    buffer[index++] = 0;
  }

  return index;
}

<<<<<<< HEAD
function serializeBinary(buffer: Uint8Array, key: string, value: Binary, index: number) {
  // Write the type
  buffer[index++] = constants.BSON_DATA_BINARY;
  // Number of written bytes
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
=======
function serializeBinary(
  buffer: Buffer,
  key: string,
  value: Binary,
  index: number,
  isArray?: boolean
) {
  // Write the type
  buffer[index++] = constants.BSON_DATA_BINARY;
  // Number of written bytes
  const numberOfWrittenBytes = !isArray
    ? buffer.write(key, index, undefined, 'utf8')
    : buffer.write(key, index, undefined, 'ascii');
>>>>>>> main
  // Encode the name
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  // Extract the buffer
<<<<<<< HEAD
  const data = value.buffer;
=======
  const data = value.value(true) as Buffer | Uint8Array;
>>>>>>> main
  // Calculate size
  let size = value.position;
  // Add the deprecated 02 type 4 bytes of size to total
  if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) size = size + 4;
  // Write the size of the string to buffer
  buffer[index++] = size & 0xff;
  buffer[index++] = (size >> 8) & 0xff;
  buffer[index++] = (size >> 16) & 0xff;
  buffer[index++] = (size >> 24) & 0xff;
  // Write the subtype to the buffer
  buffer[index++] = value.sub_type;

  // If we have binary type 2 the 4 first bytes are the size
  if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {
    size = size - 4;
    buffer[index++] = size & 0xff;
    buffer[index++] = (size >> 8) & 0xff;
    buffer[index++] = (size >> 16) & 0xff;
    buffer[index++] = (size >> 24) & 0xff;
  }

  // Write the data to the object
  buffer.set(data, index);
  // Adjust the index
  index = index + value.position;
  return index;
}

<<<<<<< HEAD
function serializeSymbol(buffer: Uint8Array, key: string, value: BSONSymbol, index: number) {
  // Write the type
  buffer[index++] = constants.BSON_DATA_SYMBOL;
  // Number of written bytes
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
=======
function serializeSymbol(
  buffer: Buffer,
  key: string,
  value: BSONSymbol,
  index: number,
  isArray?: boolean
) {
  // Write the type
  buffer[index++] = constants.BSON_DATA_SYMBOL;
  // Number of written bytes
  const numberOfWrittenBytes = !isArray
    ? buffer.write(key, index, undefined, 'utf8')
    : buffer.write(key, index, undefined, 'ascii');
>>>>>>> main
  // Encode the name
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;
  // Write the string
<<<<<<< HEAD
  const size = ByteUtils.encodeUTF8Into(buffer, value.value, index + 4) + 1;
=======
  const size = buffer.write(value.value, index + 4, undefined, 'utf8') + 1;
>>>>>>> main
  // Write the size of the string to buffer
  buffer[index] = size & 0xff;
  buffer[index + 1] = (size >> 8) & 0xff;
  buffer[index + 2] = (size >> 16) & 0xff;
  buffer[index + 3] = (size >> 24) & 0xff;
  // Update index
  index = index + 4 + size - 1;
  // Write zero
  buffer[index++] = 0x00;
  return index;
}

function serializeDBRef(
<<<<<<< HEAD
  buffer: Uint8Array,
=======
  buffer: Buffer,
>>>>>>> main
  key: string,
  value: DBRef,
  index: number,
  depth: number,
  serializeFunctions: boolean,
<<<<<<< HEAD
  path: Set<Document>
=======
  isArray?: boolean
>>>>>>> main
) {
  // Write the type
  buffer[index++] = constants.BSON_DATA_OBJECT;
  // Number of written bytes
<<<<<<< HEAD
  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);
=======
  const numberOfWrittenBytes = !isArray
    ? buffer.write(key, index, undefined, 'utf8')
    : buffer.write(key, index, undefined, 'ascii');
>>>>>>> main

  // Encode the name
  index = index + numberOfWrittenBytes;
  buffer[index++] = 0;

  let startIndex = index;
  let output: DBRefLike = {
    $ref: value.collection || value.namespace, // "namespace" was what library 1.x called "collection"
    $id: value.oid
  };

  if (value.db != null) {
    output.$db = value.db;
  }

  output = Object.assign(output, value.fields);
<<<<<<< HEAD
  const endIndex = serializeInto(
    buffer,
    output,
    false,
    index,
    depth + 1,
    serializeFunctions,
    true,
    path
  );
=======
  const endIndex = serializeInto(buffer, output, false, index, depth + 1, serializeFunctions);
>>>>>>> main

  // Calculate object size
  const size = endIndex - startIndex;
  // Write the size
  buffer[startIndex++] = size & 0xff;
  buffer[startIndex++] = (size >> 8) & 0xff;
  buffer[startIndex++] = (size >> 16) & 0xff;
  buffer[startIndex++] = (size >> 24) & 0xff;
  // Set index
  return endIndex;
}

export function serializeInto(
<<<<<<< HEAD
  buffer: Uint8Array,
  object: Document,
  checkKeys: boolean,
  startingIndex: number,
  depth: number,
  serializeFunctions: boolean,
  ignoreUndefined: boolean,
  path: Set<Document> | null
): number {
  if (path == null) {
    // We are at the root input
    if (object == null) {
      // ONLY the root should turn into an empty document
      // BSON Empty document has a size of 5 (LE)
      buffer[0] = 0x05;
      buffer[1] = 0x00;
      buffer[2] = 0x00;
      buffer[3] = 0x00;
      // All documents end with null terminator
      buffer[4] = 0x00;
      return 5;
    }

    if (Array.isArray(object)) {
      throw new BSONError('serialize does not support an array as the root input');
    }
    if (typeof object !== 'object') {
      throw new BSONError('serialize does not support non-object as the root input');
    } else if ('_bsontype' in object && typeof object._bsontype === 'string') {
      throw new BSONError(`BSON types cannot be serialized as a document`);
    } else if (
      isDate(object) ||
      isRegExp(object) ||
      isUint8Array(object) ||
      isAnyArrayBuffer(object)
    ) {
      throw new BSONError(`date, regexp, typedarray, and arraybuffer cannot be BSON documents`);
    }

    path = new Set();
  }

  // Push the object to the path
  path.add(object);
=======
  buffer: Buffer,
  object: Document,
  checkKeys = false,
  startingIndex = 0,
  depth = 0,
  serializeFunctions = false,
  ignoreUndefined = true,
  path: Document[] = []
): number {
  startingIndex = startingIndex || 0;
  path = path || [];

  // Push the object to the path
  path.push(object);
>>>>>>> main

  // Start place to serialize into
  let index = startingIndex + 4;

  // Special case isArray
  if (Array.isArray(object)) {
    // Get object keys
    for (let i = 0; i < object.length; i++) {
      const key = `${i}`;
      let value = object[i];

      // Is there an override value
      if (typeof value?.toBSON === 'function') {
        value = value.toBSON();
      }

      if (typeof value === 'string') {
<<<<<<< HEAD
        index = serializeString(buffer, key, value, index);
      } else if (typeof value === 'number') {
        index = serializeNumber(buffer, key, value, index);
      } else if (typeof value === 'bigint') {
        index = serializeBigInt(buffer, key, value, index);
      } else if (typeof value === 'boolean') {
        index = serializeBoolean(buffer, key, value, index);
      } else if (value instanceof Date || isDate(value)) {
        index = serializeDate(buffer, key, value, index);
      } else if (value === undefined) {
        index = serializeNull(buffer, key, value, index);
      } else if (value === null) {
        index = serializeNull(buffer, key, value, index);
      } else if (isUint8Array(value)) {
        index = serializeBuffer(buffer, key, value, index);
      } else if (value instanceof RegExp || isRegExp(value)) {
        index = serializeRegExp(buffer, key, value, index);
      } else if (typeof value === 'object' && value._bsontype == null) {
=======
        index = serializeString(buffer, key, value, index, true);
      } else if (typeof value === 'number') {
        index = serializeNumber(buffer, key, value, index, true);
      } else if (typeof value === 'bigint') {
        throw new BSONTypeError('Unsupported type BigInt, please use Decimal128');
      } else if (typeof value === 'boolean') {
        index = serializeBoolean(buffer, key, value, index, true);
      } else if (value instanceof Date || isDate(value)) {
        index = serializeDate(buffer, key, value, index, true);
      } else if (value === undefined) {
        index = serializeNull(buffer, key, value, index, true);
      } else if (value === null) {
        index = serializeNull(buffer, key, value, index, true);
      } else if (value['_bsontype'] === 'ObjectId' || value['_bsontype'] === 'ObjectID') {
        index = serializeObjectId(buffer, key, value, index, true);
      } else if (isUint8Array(value)) {
        index = serializeBuffer(buffer, key, value, index, true);
      } else if (value instanceof RegExp || isRegExp(value)) {
        index = serializeRegExp(buffer, key, value, index, true);
      } else if (typeof value === 'object' && value['_bsontype'] == null) {
>>>>>>> main
        index = serializeObject(
          buffer,
          key,
          value,
          index,
          checkKeys,
          depth,
          serializeFunctions,
          ignoreUndefined,
<<<<<<< HEAD
=======
          true,
>>>>>>> main
          path
        );
      } else if (
        typeof value === 'object' &&
<<<<<<< HEAD
        value[Symbol.for('@@mdb.bson.version')] !== constants.BSON_MAJOR_VERSION
      ) {
        throw new BSONVersionError();
      } else if (value._bsontype === 'ObjectId') {
        index = serializeObjectId(buffer, key, value, index);
      } else if (value._bsontype === 'Decimal128') {
        index = serializeDecimal128(buffer, key, value, index);
      } else if (value._bsontype === 'Long' || value._bsontype === 'Timestamp') {
        index = serializeLong(buffer, key, value, index);
      } else if (value._bsontype === 'Double') {
        index = serializeDouble(buffer, key, value, index);
      } else if (typeof value === 'function' && serializeFunctions) {
        index = serializeFunction(buffer, key, value, index);
      } else if (value._bsontype === 'Code') {
=======
        isBSONType(value) &&
        value._bsontype === 'Decimal128'
      ) {
        index = serializeDecimal128(buffer, key, value, index, true);
      } else if (value['_bsontype'] === 'Long' || value['_bsontype'] === 'Timestamp') {
        index = serializeLong(buffer, key, value, index, true);
      } else if (value['_bsontype'] === 'Double') {
        index = serializeDouble(buffer, key, value, index, true);
      } else if (typeof value === 'function' && serializeFunctions) {
        index = serializeFunction(buffer, key, value, index, checkKeys, depth, true);
      } else if (value['_bsontype'] === 'Code') {
>>>>>>> main
        index = serializeCode(
          buffer,
          key,
          value,
          index,
          checkKeys,
          depth,
          serializeFunctions,
          ignoreUndefined,
<<<<<<< HEAD
          path
        );
      } else if (value._bsontype === 'Binary') {
        index = serializeBinary(buffer, key, value, index);
      } else if (value._bsontype === 'BSONSymbol') {
        index = serializeSymbol(buffer, key, value, index);
      } else if (value._bsontype === 'DBRef') {
        index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path);
      } else if (value._bsontype === 'BSONRegExp') {
        index = serializeBSONRegExp(buffer, key, value, index);
      } else if (value._bsontype === 'Int32') {
        index = serializeInt32(buffer, key, value, index);
      } else if (value._bsontype === 'MinKey' || value._bsontype === 'MaxKey') {
        index = serializeMinMax(buffer, key, value, index);
      } else if (typeof value._bsontype !== 'undefined') {
        throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);
=======
          true
        );
      } else if (value['_bsontype'] === 'Binary') {
        index = serializeBinary(buffer, key, value, index, true);
      } else if (value['_bsontype'] === 'Symbol') {
        index = serializeSymbol(buffer, key, value, index, true);
      } else if (value['_bsontype'] === 'DBRef') {
        index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, true);
      } else if (value['_bsontype'] === 'BSONRegExp') {
        index = serializeBSONRegExp(buffer, key, value, index, true);
      } else if (value['_bsontype'] === 'Int32') {
        index = serializeInt32(buffer, key, value, index, true);
      } else if (value['_bsontype'] === 'MinKey' || value['_bsontype'] === 'MaxKey') {
        index = serializeMinMax(buffer, key, value, index, true);
      } else if (typeof value['_bsontype'] !== 'undefined') {
        throw new BSONTypeError(`Unrecognized or invalid _bsontype: ${String(value['_bsontype'])}`);
>>>>>>> main
      }
    }
  } else if (object instanceof Map || isMap(object)) {
    const iterator = object.entries();
    let done = false;

    while (!done) {
      // Unpack the next entry
      const entry = iterator.next();
      done = !!entry.done;
      // Are we done, then skip and terminate
      if (done) continue;

      // Get the entry values
      const key = entry.value[0];
<<<<<<< HEAD
      let value = entry.value[1];

      if (typeof value?.toBSON === 'function') {
        value = value.toBSON();
      }
=======
      const value = entry.value[1];
>>>>>>> main

      // Check the type of the value
      const type = typeof value;

      // Check the key and throw error if it's illegal
      if (typeof key === 'string' && !ignoreKeys.has(key)) {
        if (key.match(regexp) != null) {
          // The BSON spec doesn't allow keys with null bytes because keys are
          // null-terminated.
<<<<<<< HEAD
          throw new BSONError('key ' + key + ' must not contain null bytes');
=======
          throw Error('key ' + key + ' must not contain null bytes');
>>>>>>> main
        }

        if (checkKeys) {
          if ('$' === key[0]) {
<<<<<<< HEAD
            throw new BSONError('key ' + key + " must not start with '$'");
          } else if (~key.indexOf('.')) {
            throw new BSONError('key ' + key + " must not contain '.'");
=======
            throw Error('key ' + key + " must not start with '$'");
          } else if (~key.indexOf('.')) {
            throw Error('key ' + key + " must not contain '.'");
>>>>>>> main
          }
        }
      }

      if (type === 'string') {
        index = serializeString(buffer, key, value, index);
      } else if (type === 'number') {
        index = serializeNumber(buffer, key, value, index);
<<<<<<< HEAD
      } else if (type === 'bigint') {
        index = serializeBigInt(buffer, key, value, index);
=======
      } else if (type === 'bigint' || isBigInt64Array(value) || isBigUInt64Array(value)) {
        throw new BSONTypeError('Unsupported type BigInt, please use Decimal128');
>>>>>>> main
      } else if (type === 'boolean') {
        index = serializeBoolean(buffer, key, value, index);
      } else if (value instanceof Date || isDate(value)) {
        index = serializeDate(buffer, key, value, index);
      } else if (value === null || (value === undefined && ignoreUndefined === false)) {
        index = serializeNull(buffer, key, value, index);
<<<<<<< HEAD
=======
      } else if (value['_bsontype'] === 'ObjectId' || value['_bsontype'] === 'ObjectID') {
        index = serializeObjectId(buffer, key, value, index);
>>>>>>> main
      } else if (isUint8Array(value)) {
        index = serializeBuffer(buffer, key, value, index);
      } else if (value instanceof RegExp || isRegExp(value)) {
        index = serializeRegExp(buffer, key, value, index);
<<<<<<< HEAD
      } else if (type === 'object' && value._bsontype == null) {
=======
      } else if (type === 'object' && value['_bsontype'] == null) {
>>>>>>> main
        index = serializeObject(
          buffer,
          key,
          value,
          index,
          checkKeys,
          depth,
          serializeFunctions,
          ignoreUndefined,
<<<<<<< HEAD
          path
        );
      } else if (
        typeof value === 'object' &&
        value[Symbol.for('@@mdb.bson.version')] !== constants.BSON_MAJOR_VERSION
      ) {
        throw new BSONVersionError();
      } else if (value._bsontype === 'ObjectId') {
        index = serializeObjectId(buffer, key, value, index);
      } else if (type === 'object' && value._bsontype === 'Decimal128') {
        index = serializeDecimal128(buffer, key, value, index);
      } else if (value._bsontype === 'Long' || value._bsontype === 'Timestamp') {
        index = serializeLong(buffer, key, value, index);
      } else if (value._bsontype === 'Double') {
        index = serializeDouble(buffer, key, value, index);
      } else if (value._bsontype === 'Code') {
=======
          false,
          path
        );
      } else if (type === 'object' && value['_bsontype'] === 'Decimal128') {
        index = serializeDecimal128(buffer, key, value, index);
      } else if (value['_bsontype'] === 'Long' || value['_bsontype'] === 'Timestamp') {
        index = serializeLong(buffer, key, value, index);
      } else if (value['_bsontype'] === 'Double') {
        index = serializeDouble(buffer, key, value, index);
      } else if (value['_bsontype'] === 'Code') {
>>>>>>> main
        index = serializeCode(
          buffer,
          key,
          value,
          index,
          checkKeys,
          depth,
          serializeFunctions,
<<<<<<< HEAD
          ignoreUndefined,
          path
        );
      } else if (typeof value === 'function' && serializeFunctions) {
        index = serializeFunction(buffer, key, value, index);
      } else if (value._bsontype === 'Binary') {
        index = serializeBinary(buffer, key, value, index);
      } else if (value._bsontype === 'BSONSymbol') {
        index = serializeSymbol(buffer, key, value, index);
      } else if (value._bsontype === 'DBRef') {
        index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path);
      } else if (value._bsontype === 'BSONRegExp') {
        index = serializeBSONRegExp(buffer, key, value, index);
      } else if (value._bsontype === 'Int32') {
        index = serializeInt32(buffer, key, value, index);
      } else if (value._bsontype === 'MinKey' || value._bsontype === 'MaxKey') {
        index = serializeMinMax(buffer, key, value, index);
      } else if (typeof value._bsontype !== 'undefined') {
        throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);
=======
          ignoreUndefined
        );
      } else if (typeof value === 'function' && serializeFunctions) {
        index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions);
      } else if (value['_bsontype'] === 'Binary') {
        index = serializeBinary(buffer, key, value, index);
      } else if (value['_bsontype'] === 'Symbol') {
        index = serializeSymbol(buffer, key, value, index);
      } else if (value['_bsontype'] === 'DBRef') {
        index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions);
      } else if (value['_bsontype'] === 'BSONRegExp') {
        index = serializeBSONRegExp(buffer, key, value, index);
      } else if (value['_bsontype'] === 'Int32') {
        index = serializeInt32(buffer, key, value, index);
      } else if (value['_bsontype'] === 'MinKey' || value['_bsontype'] === 'MaxKey') {
        index = serializeMinMax(buffer, key, value, index);
      } else if (typeof value['_bsontype'] !== 'undefined') {
        throw new BSONTypeError(`Unrecognized or invalid _bsontype: ${String(value['_bsontype'])}`);
>>>>>>> main
      }
    }
  } else {
    if (typeof object?.toBSON === 'function') {
      // Provided a custom serialization method
      object = object.toBSON();
      if (object != null && typeof object !== 'object') {
<<<<<<< HEAD
        throw new BSONError('toBSON function did not return an object');
=======
        throw new BSONTypeError('toBSON function did not return an object');
>>>>>>> main
      }
    }

    // Iterate over all the keys
<<<<<<< HEAD
    for (const key of Object.keys(object)) {
=======
    for (const key in object) {
>>>>>>> main
      let value = object[key];
      // Is there an override value
      if (typeof value?.toBSON === 'function') {
        value = value.toBSON();
      }

      // Check the type of the value
      const type = typeof value;

      // Check the key and throw error if it's illegal
      if (typeof key === 'string' && !ignoreKeys.has(key)) {
        if (key.match(regexp) != null) {
          // The BSON spec doesn't allow keys with null bytes because keys are
          // null-terminated.
<<<<<<< HEAD
          throw new BSONError('key ' + key + ' must not contain null bytes');
=======
          throw Error('key ' + key + ' must not contain null bytes');
>>>>>>> main
        }

        if (checkKeys) {
          if ('$' === key[0]) {
<<<<<<< HEAD
            throw new BSONError('key ' + key + " must not start with '$'");
          } else if (~key.indexOf('.')) {
            throw new BSONError('key ' + key + " must not contain '.'");
=======
            throw Error('key ' + key + " must not start with '$'");
          } else if (~key.indexOf('.')) {
            throw Error('key ' + key + " must not contain '.'");
>>>>>>> main
          }
        }
      }

      if (type === 'string') {
        index = serializeString(buffer, key, value, index);
      } else if (type === 'number') {
        index = serializeNumber(buffer, key, value, index);
      } else if (type === 'bigint') {
<<<<<<< HEAD
        index = serializeBigInt(buffer, key, value, index);
=======
        throw new BSONTypeError('Unsupported type BigInt, please use Decimal128');
>>>>>>> main
      } else if (type === 'boolean') {
        index = serializeBoolean(buffer, key, value, index);
      } else if (value instanceof Date || isDate(value)) {
        index = serializeDate(buffer, key, value, index);
      } else if (value === undefined) {
        if (ignoreUndefined === false) index = serializeNull(buffer, key, value, index);
      } else if (value === null) {
        index = serializeNull(buffer, key, value, index);
<<<<<<< HEAD
=======
      } else if (value['_bsontype'] === 'ObjectId' || value['_bsontype'] === 'ObjectID') {
        index = serializeObjectId(buffer, key, value, index);
>>>>>>> main
      } else if (isUint8Array(value)) {
        index = serializeBuffer(buffer, key, value, index);
      } else if (value instanceof RegExp || isRegExp(value)) {
        index = serializeRegExp(buffer, key, value, index);
<<<<<<< HEAD
      } else if (type === 'object' && value._bsontype == null) {
=======
      } else if (type === 'object' && value['_bsontype'] == null) {
>>>>>>> main
        index = serializeObject(
          buffer,
          key,
          value,
          index,
          checkKeys,
          depth,
          serializeFunctions,
          ignoreUndefined,
<<<<<<< HEAD
          path
        );
      } else if (
        typeof value === 'object' &&
        value[Symbol.for('@@mdb.bson.version')] !== constants.BSON_MAJOR_VERSION
      ) {
        throw new BSONVersionError();
      } else if (value._bsontype === 'ObjectId') {
        index = serializeObjectId(buffer, key, value, index);
      } else if (type === 'object' && value._bsontype === 'Decimal128') {
        index = serializeDecimal128(buffer, key, value, index);
      } else if (value._bsontype === 'Long' || value._bsontype === 'Timestamp') {
        index = serializeLong(buffer, key, value, index);
      } else if (value._bsontype === 'Double') {
        index = serializeDouble(buffer, key, value, index);
      } else if (value._bsontype === 'Code') {
=======
          false,
          path
        );
      } else if (type === 'object' && value['_bsontype'] === 'Decimal128') {
        index = serializeDecimal128(buffer, key, value, index);
      } else if (value['_bsontype'] === 'Long' || value['_bsontype'] === 'Timestamp') {
        index = serializeLong(buffer, key, value, index);
      } else if (value['_bsontype'] === 'Double') {
        index = serializeDouble(buffer, key, value, index);
      } else if (value['_bsontype'] === 'Code') {
>>>>>>> main
        index = serializeCode(
          buffer,
          key,
          value,
          index,
          checkKeys,
          depth,
          serializeFunctions,
<<<<<<< HEAD
          ignoreUndefined,
          path
        );
      } else if (typeof value === 'function' && serializeFunctions) {
        index = serializeFunction(buffer, key, value, index);
      } else if (value._bsontype === 'Binary') {
        index = serializeBinary(buffer, key, value, index);
      } else if (value._bsontype === 'BSONSymbol') {
        index = serializeSymbol(buffer, key, value, index);
      } else if (value._bsontype === 'DBRef') {
        index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path);
      } else if (value._bsontype === 'BSONRegExp') {
        index = serializeBSONRegExp(buffer, key, value, index);
      } else if (value._bsontype === 'Int32') {
        index = serializeInt32(buffer, key, value, index);
      } else if (value._bsontype === 'MinKey' || value._bsontype === 'MaxKey') {
        index = serializeMinMax(buffer, key, value, index);
      } else if (typeof value._bsontype !== 'undefined') {
        throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);
=======
          ignoreUndefined
        );
      } else if (typeof value === 'function' && serializeFunctions) {
        index = serializeFunction(buffer, key, value, index, checkKeys, depth, serializeFunctions);
      } else if (value['_bsontype'] === 'Binary') {
        index = serializeBinary(buffer, key, value, index);
      } else if (value['_bsontype'] === 'Symbol') {
        index = serializeSymbol(buffer, key, value, index);
      } else if (value['_bsontype'] === 'DBRef') {
        index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions);
      } else if (value['_bsontype'] === 'BSONRegExp') {
        index = serializeBSONRegExp(buffer, key, value, index);
      } else if (value['_bsontype'] === 'Int32') {
        index = serializeInt32(buffer, key, value, index);
      } else if (value['_bsontype'] === 'MinKey' || value['_bsontype'] === 'MaxKey') {
        index = serializeMinMax(buffer, key, value, index);
      } else if (typeof value['_bsontype'] !== 'undefined') {
        throw new BSONTypeError(`Unrecognized or invalid _bsontype: ${String(value['_bsontype'])}`);
>>>>>>> main
      }
    }
  }

  // Remove the path
<<<<<<< HEAD
  path.delete(object);
=======
  path.pop();
>>>>>>> main

  // Final padding byte for object
  buffer[index++] = 0x00;

  // Final size
  const size = index - startingIndex;
  // Write the size of the object
  buffer[startingIndex++] = size & 0xff;
  buffer[startingIndex++] = (size >> 8) & 0xff;
  buffer[startingIndex++] = (size >> 16) & 0xff;
  buffer[startingIndex++] = (size >> 24) & 0xff;
  return index;
}
